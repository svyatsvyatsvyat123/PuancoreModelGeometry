### Что это такое?
Это наш с Кустовым Вадимом проект - аналог всем известной [геогебры](https://www.geogebra.org/geometry), но только для геометрии Лобачевского, а именно [модели Пуанкаре в верхней полуплоскости](https://ru.wikipedia.org/wiki/Модель_Пуанкаре_в_верхней_полуплоскости).
### Что тут есть?
Все главные геометрические объекты: 
Точка, прямая, луч, отрезок, окружность и ее дуга.
Также есть множество функций для взаимодействия с ними.
Большество из них(а, может, в момент вашего прочтения, и все) можно выбрать из менюшки, но для остальных времено стоят горячие клавиши. Если они есть, то я буду писать их в круглых скобках.
Если функция просит точку, но ее не существует на координатах мыши, то точка там появится.
Все обьекты имеют строгую иерархию. Она определяется с помощью функций. Например: вы решили посторить перпендикуляр к данной прямой из данной точки. Тогда этот перпендикуляр будет _зависеть_ от этой точки и прямой, что означает следующее: если точка _пропадет_ или будет удалена, то то же случиться и с перпендикуляром. Если же точка поменяет местоположение, то перпендикуляр тоже изменится, чтобы проходить через эту точку. Я буду писать, если обьект может не существовать.
Если объект пропал, то он больше не отрисовывается. Обычно это происходит, когда его не существует. Может также пропасть из-за багов.
1) __Передвижение__. Вы можете схватить мышкой точку и передвинуть в другое место. 
   В будующем добавим возможность перемещать камеру этим режимом.
   Прим.: нельзя поставить точку ниже минимальной координаты и нельзя двигать недвижимые точки. 
2) __Постановка новой точки__. Создает новую точку на координатх мыши, если она там еще не существует
3) __Удаление__. Удаляет все объекты, на которые указывает мышка при нажатом ЛКМ. 
   Если у объекта есть зависимые от него объекты, то все они тоже будут удалены.
4) __Отрезок по двум точкам__. Создает отрезок по двум точкам.
5) __Луч по двум точкам__. Создает луч по двум точкам
6) __Прямая по двум точкам__. Создает прямую по двум точкам.
7) __Окружность по центру и точке на ней__. Создает окружность по центру и точке на ней.
8) __Окружность по трем точкам__. Создает окружность проходящуюю через 3 данных точки.
    Прим.: Окружность может не существовать. 
9) __Середина обьекта__. На вход берет 2 точки/отрезок или окружность.
   Создает точку по их середине(если на вход окружность, то ставит точку по ее центру)
10) __Пересечение__. Ставит до двух точек на пересечении двух любых обьектов кроме точек.
    Прим.: всегда создается 2 точки, если пересечений меньше, чем 2 то лишние точки _пропадают_.
    Вызывается по клавише I.
11) __Перпендикуляр__. Рисует перпендикуляр к отрезку/прямой/лучу через данную точку. 
    Вызывается по клавише P.
12) __Серпер__. Создает серединный перпендикуляр к данному отрезку
    Вызывается по клавише M.
13) __Дуга окружности__. Создает дугу окружности по трем данным точкам. 
    Только вторая точка отвечает за длину радиуса. 
    Вызывается по клавише U.
14) __Паралельные прямые__. На вход прямая/отрезок/луч и точка. 
    В геометрии лобачевского их бесконечное количество, поэтому создается только 2 крайние.
    Вызывается по клавише X

Чтобы выйти нажмите esc;
Также можно двигать камеру с помощью WASD.
Чтобы увеличить размер камеры(говоря иначе - зум) есть стрелки вверх и вниз
Прим.: Нельзя опуститься так, чтобы "увидеть" минимальную координату. Аналогично с размером камеры.
Все картинки, цвета и менюшку создал Вадим. Остальной код и всю документацию-Я.
Ни одной функции не было бы создано без помощи Владимира Евгеньевича. Огромное спасибо ему!!!
### А как все работает изнутри?
Это длинная и скучная часть про бекенд приложения и она создана только для тех, кому это интересно, если вам это не нужно то просто пропустите.
Хоть в геометрии и 6 обьектов, по факту я использую всего 2-круг(точка) и Linerenderer- он умеет рисовать любую ломаную. Он отвечает за все остальное. У них обоих есть хитбокс, который на языке Unity называется Collider. Если пустить луч, то он сможет в них врезаться и вернет все, во что врезался. Это называется Raycast.
Так же все обьекты хранят в себе информацию о себе - для этого есть класс WhatIsThat. Он хранит в себе тип обьекта, переменную отвечающую за возможность ее перемещенияи ключевые точки- точки по которым можно легко определить этот обьект. Например: прямую можно посторить по двум точкам, и если мне нужно ее сохранить, то я их запишу в компонент WhatIsThat у данной прямой.
Кстати, тип обьекта это не просто строка, а отдельный класс, а точнее enum.
Он хранит в себе константы в виде чисел, степеней двоек, для каждого типа. Например для точки он = 1 а для прямой 16, это сделано для того, чтобы можно было удобно задавать запросы. Например я хочу для функции перпендикуляра получить отрезок или луч или прямую первым аргументом. Тогда я могу записать это в виде "битого или" трех чисел-отрезка,прямой и луча. А когда я проверяю содержит ли мой запрос прямую, я могу взять "битовый и" запроса и прямой, и посмотреть, равен ли он прямой. 
Пойдемся по остальным классам.
__CoordsTransformator__ - умеет переводить координаты мыши в координаты на плоскости. По факту просто формула.
__ObjectsGetter__ - выдает все обьекты удовлетворяющие данным параметрам на данных координатах мыши. Он использует тот самый Raycast, о котором я писал выше.
__PointGetter__ - имеет две функции create - создать на данных координатах поля новую точку с заданными параметрами и get которая выдает точку на данных координатах мыши, используя ObjectGetter. Имеет в себе параметр, который создает точку, если ее не существует.
__CameraMover__ Этот скрипт двигает камеру
__SelectPoint__ Этот скрипт есть только у точек. Он позволяет их выделять. В будующем добавлю выделение и остальных объектов.
Теперь пора поговорить про сами обновления кадров и обьектов.
#### Обновления кадров
Перед разбором функций важно отметить еще 1 класс- __UpdateScriptSuppport__(сокр. __USS__).
Он хранит в себе все, что нужно для отрисовки объекта. А именно:

1) Обьекты-родители, а так же их типы. Те обьекты от которых зависит данный
2) Параметры. Массив из стандартных точек- точек, способных описать любой объект. Они обновляются каждый кадр. Если они не изменились за кадр, то обьект в этом кадре не обновляется и остается таким же, что очень сильно повышает производительность.
3) _draw_. Это функция для отрисовки обьекта. Она вызывается если параметры поменялись.
4) _getStandardPoints_. Она обновляет стандратные точки данного обьекта. 
5) Сам обьект, который обновляют(ну куда же без него).

Причем __USS__ это просто красивая и удобная обертка для хранения и обновления всего этого по вызову функции Work, что значит, что эту функцию должен кто-то вызывать. Но о __нем__  расскажу позже.  
Важно понимать, что все это не берется из ниоткуда, а передается при инициализации класса __USS__. И именно для их задания и существуют все функциии, ну или почти все.
Каждая функция это класс, унаследованый от класса __BaseMode__(поэтому я их называю модами), и переопределяющий функцию _Finish_ и _Update_. _Finish_ вызывается каждый раз, когда мод заменяется на другой. Служит он например для девыделения выбранных объектов. А _Update_ вызывается каждый кадр, и именно в нем __MoveMode__ передвигает точки, а __DeleteMode__ стирает все лишь при одном касании. Это 2 из трех модов, которые прямо унаследованы от __BaseMode__. А последний, и самый главный это
__DrawMode__ - от него унаследованы все остальные. Важно понимать что по факту это класс по созданию модов, так что и конструктор у него отличается от остальных, ведь у них он пустой. Он принимает в себя типы обьектов, которые нужно получить и тип создаваемого обьекта.
В своем методе _Update_ он (если мышь нажата) пытается по ее координатам с помощью __ObjectGetter__  получить объект нужного на данном этапе типа(если нужно получить точку и ее нет, то он ее создает) и сохраняет его самого, его тип и его standardPoints, чтобы с помощью них проверить на то, что обьект уже выбран, и не выбирать его заного. Затем, когда все параметры собраны, он передает их в __USS__. Но стоп, откуда он взял _draw_ и _getStandardPoints_, которые нужны __USS__? Ни от куда. Ведь у него их нет. Точнее они есть, но пустые, и определяют их уже классы, унаследованные от __DrawMode__.(Так же они переопределяют метод _init_, который вызывается один раз до вызова первого draw).
А теперь разберем это на примере рисования прямой между двумя точками, чтобы было понятно. Для этого нам понадобиться:

1) Создать новый класс __LineMode__ унаследованный от класса __DrawMode__
2) В его конструкторе(без аргументнов) вызвать конструктор класса DrawMode с массивом из чисел, которые обозначают точки, а вторым аргументом передать число, означающее прямую.
3) Задать функции _init_, _draw_ и _getStandardPoints_, в которых и происходит основная логика обновлений обьекта.
4) Спустя некоторое время после того, как пользователь выбрал нужные обьекты, __DrawMode__ сам соберет с них нужную информацию и создаст по ней __USS__. Конец!

Но стоп, __USS__  же всего-лишь удобный помошник, и сам ничего делать не будет, чтобы объект обновился, нужно, чтобы кто-то обновлял __USS__и более того, следил за порядком обновлений, ведь иначе ничего хорошего не выйдет. Это правда, существует последний класс, про который я еще не рассказывал. И это
__UpdateScript__. Да, я думаю вы о его названии догодались еще давно, тк у меня не очень с фантазией, но да ладно. Он хранит в себе массив из __USS__ и обновляет их каждый кадр просто проходя по нему, и удаляя некоторые из них, если обьекты, которые они хранили, были уничтожены. DrawMode в самом конце просто добавляет в его конец новые __USS__. И этого достаточно, ведь все что нужно - обновлять родителей раньше детей, и это работает, ведь родители создаются раньше детей, а значит лежат в этом массиве до них.
Так же этот класс обновляет моды, к которым еще не пределали кнопку для их выбора.


Подытожим. PointGetter и ObjectGetter получают обьекты с поля, которые передаются на вход Модам, которые по ним создают новые обьекты и передают их USS, который умеет их грамотно обновлять, и добавляют этот USS в UpdateScript, который уже и обновляет эти USS. THE END